(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{508:function(e,r,o){"use strict";o.r(r);var a=o(22),v=Object(a.a)({},(function(){var e=this,r=e.$createElement,o=e._self._c||r;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h4",{attrs:{id:"_1、zookeeper的角色"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1、zookeeper的角色"}},[e._v("#")]),e._v(" 1、Zookeeper的角色")]),e._v(" "),o("p",[e._v("» 领导者（leader），负责进行投票的发起和决议，更新系统状态\n　» 学习者（learner），包括跟随者（follower）和观察者（observer），follower用于接受客户端请求并想客户端返回结果，在选主过程中参与投票\n　» Observer可以接受客户端连接，将写请求转发给leader，但observer不参加投票过程，只同步leader的状态，observer的目的是为了扩展系统，提高读取速度\n　» 客户端（client），请求发起方")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/opersdev/image/i/2022/06/13/62a6e6e5dfff8.png",alt:"https://images2015.cnblogs.com/blog/183233/201603/183233-20160316222444771-1363762533.png"}})]),e._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/opersdev/image/i/2022/06/13/62a6e6e6201c8.jpg",alt:"https://images2015.cnblogs.com/blog/183233/201603/183233-20160316222520584-1877673765.jpg"}})]),e._v(" "),o("p",[e._v("• Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协\n　  议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者\n　　崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后\n　  ，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。")]),e._v(" "),o("p",[e._v("• 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（\n　　proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识\n　  leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的\n　　统治时期。低32位用于递增计数。\n　• 每个Server在工作过程中有三种状态：\n　　　LOOKING：当前Server不知道leader是谁，正在搜寻\n　　　LEADING：当前Server即为选举出来的leader\n　　　FOLLOWING：leader已经选举出来，当前Server与之同步")]),e._v(" "),o("p",[e._v("其他文档：http://www.cnblogs.com/lpshou/archive/2013/06/14/3136738.html")]),e._v(" "),o("h4",{attrs:{id:"_2、zookeeper-的读写机制"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2、zookeeper-的读写机制"}},[e._v("#")]),e._v(" "),o("strong",[e._v("2")]),e._v("、Zookeeper 的读写机制")]),e._v(" "),o("p",[e._v("» Zookeeper是一个由多个server组成的集群\n　» 一个leader，多个follower\n　» 每个server保存一份数据副本\n　» 全局数据一致\n　» 分布式读写\n　» 更新请求转发，由leader实施")]),e._v(" "),o("h4",{attrs:{id:"_3、zookeeper-的保证"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3、zookeeper-的保证"}},[e._v("#")]),e._v(" "),o("strong",[e._v("3")]),e._v("、Zookeeper 的保证")]),e._v(" "),o("p",[e._v("» 更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行\n　» 数据更新原子性，一次数据更新要么成功，要么失败\n　» 全局唯一数据视图，client无论连接到哪个server，数据视图都是一致的\n　» 实时性，在一定事件范围内，client能读到最新数据")]),e._v(" "),o("h4",{attrs:{id:"_4、zookeeper节点数据操作流程"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_4、zookeeper节点数据操作流程"}},[e._v("#")]),e._v(" "),o("strong",[e._v("4")]),e._v("、Zookeeper节点数据操作流程")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/opersdev/image/i/2022/06/13/62a6e6e65b08c.png",alt:"https://images2015.cnblogs.com/blog/183233/201603/183233-20160316223234865-1124736424.png"}})]),e._v(" "),o("p",[e._v("注：1.在Client向Follwer发出一个写的请求")]),e._v(" "),o("p",[e._v("2.Follwer把请求发送给Leader")]),e._v(" "),o("p",[e._v("3.Leader接收到以后开始发起投票并通知Follwer进行投票")]),e._v(" "),o("p",[e._v("4.Follwer把投票结果发送给Leader")]),e._v(" "),o("p",[e._v("5.Leader将结果汇总后如果需要写入，则开始写入同时把写入操作通知给Leader，然后commit;")]),e._v(" "),o("p",[e._v("6.Follwer把请求结果返回给Client")]),e._v(" "),o("p"),e._v(" "),o("p",[e._v("• Follower主要有四个功能：\n　　　• 1. 向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；\n　　　• 2 .接收Leader消息并进行处理；\n　　　• 3 .接收Client的请求，如果为写请求，发送给Leader进行投票；\n　　　• 4 .返回Client结果。\n　　　• Follower的消息循环处理如下几种来自Leader的消息：\n　　　• 1 .PING消息： 心跳消息；\n　　　• 2 .PROPOSAL消息：Leader发起的提案，要求Follower投票；\n　　　• 3 .COMMIT消息：服务器端最新一次提案的信息；\n　　　• 4 .UPTODATE消息：表明同步完成；\n　　　• 5 .REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；\n　　　• 6 .SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。")]),e._v(" "),o("h4",{attrs:{id:"_5、zookeeper-leader-选举"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5、zookeeper-leader-选举"}},[e._v("#")]),e._v(" "),o("strong",[e._v("5")]),e._v("、Zookeeper leader 选举")]),e._v(" "),o("p",[e._v("• 半数通过\n　　　– 3台机器 挂一台 2>3/2\n　　　– 4台机器 挂2台 2！>4/2")]),e._v(" "),o("p"),e._v(" "),o("p",[e._v("• A提案说，我要选自己，B你同意吗？C你同意吗？B说，我同意选A；C说，我同意选A。(注意，这里超过半数了，其实在现实世界选举已经成功了。")]),e._v(" "),o("p",[e._v("但是计算机世界是很严格，另外要理解算法，要继续模拟下去。)\n　• 接着B提案说，我要选自己，A你同意吗；A说，我已经超半数同意当选，你的提案无效；C说，A已经超半数同意当选，B提案无效。\n　• 接着C提案说，我要选自己，A你同意吗；A说，我已经超半数同意当选，你的提案无效；B说，A已经超半数同意当选，C的提案无效。\n　• 选举已经产生了Leader，后面的都是follower，只能服从Leader的命令。而且这里还有个小细节，就是其实谁先启动谁当头。")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/opersdev/image/i/2022/06/13/62a6e6e69380f.png",alt:"https://images2015.cnblogs.com/blog/183233/201603/183233-20160316224650521-63353773.png"}})]),e._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/opersdev/image/i/2022/06/13/62a6e6e6cd1f4.png",alt:"https://images2015.cnblogs.com/blog/183233/201603/183233-20160316224702381-344312695.png"}})]),e._v(" "),o("h4",{attrs:{id:"_6、zxid"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_6、zxid"}},[e._v("#")]),e._v(" "),o("strong",[e._v("6")]),e._v("、zxid")]),e._v(" "),o("p",[e._v("• znode节点的状态信息中包含czxid, 那么什么是zxid呢?\n　• ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生.")]),e._v(" "),o("p",[e._v("创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加.")]),e._v(" "),o("h4",{attrs:{id:"_7、zookeeper工作原理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_7、zookeeper工作原理"}},[e._v("#")]),e._v(" "),o("strong",[e._v("7")]),e._v("、Zookeeper工作原理")]),e._v(" "),o("p",[e._v("» Zookeeper的核心是原子广播，这个机制保证了各个server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式和广播模式。")]),e._v(" "),o("p",[e._v("当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数server的完成了和leader的状态同步以后，恢复模式就结束了。")]),e._v(" "),o("p",[e._v("状态同步保证了leader和server具有相同的系统状态")]),e._v(" "),o("p",[e._v("» 一旦leader已经和多数的follower进行了状态同步后，他就可以开始广播消息了，即进入广播状态。这时候当一个server加入zookeeper服务中，它会在恢复模式下启动，")]),e._v(" "),o("p",[e._v("发现leader，并和leader进行状态同步。待到同步结束，它也参与消息广播。Zookeeper服务一直维持在Broadcast状态，直到leader崩溃了或者leader失去了大部分")]),e._v(" "),o("p",[e._v("的followers支持。")]),e._v(" "),o("p",[e._v("» 广播模式需要保证proposal被按顺序处理，因此zk采用了递增的事务id号(zxid)来保证。所有的提议(proposal)都在被提出的时候加上了zxid。")]),e._v(" "),o("p",[e._v("实现中zxid是一个64为的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch。低32位是个递增计数。")]),e._v(" "),o("p",[e._v("» 当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的server都恢复到一个正确的状态。")]),e._v(" "),o("p",[e._v("» 每个Server启动以后都询问其它的Server它要投票给谁。\n　» 对于其他server的询问，server每次根据自己的状态都回复自己推荐的leader的id和上一次处理事务的zxid（系统启动时每个server都会推荐自己）\n　» 收到所有Server回复以后，就计算出zxid最大的哪个Server，并将这个Server相关信息设置成下一次要投票的Server。\n　» 计算这过程中获得票数最多的的sever为获胜者，如果获胜者的票数超过半数，则改server被选为leader。否则，继续这个过程，直到leader被选举出来")]),e._v(" "),o("p",[e._v("» leader就会开始等待server连接\n　» Follower连接leader，将最大的zxid发送给leader\n　» Leader根据follower的zxid确定同步点\n　» 完成同步后通知follower 已经成为uptodate状态\n　» Follower收到uptodate消息后，又可以重新接受client的请求进行服务了")]),e._v(" "),o("h4",{attrs:{id:"_8、数据一致性与paxos-算法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_8、数据一致性与paxos-算法"}},[e._v("#")]),e._v(" "),o("strong",[e._v("8")]),e._v("、数据一致性与paxos 算法")]),e._v(" "),o("p",[e._v("• 据说Paxos算法的难理解与算法的知名度一样令人敬仰，所以我们先看如何保持数据的一致性，这里有个原则就是：\n　• 在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。\n　• Paxos算法解决的什么问题呢，解决的就是保证每个节点执行相同的操作序列。好吧，这还不简单，master维护一个\n　  全局写队列，所有写操作都必须 放入这个队列编号，那么无论我们写多少个节点，只要写操作是按编号来的，就能保证一\n　　致性。没错，就是这样，可是如果master挂了呢。\n　• Paxos算法通过投票来对写操作进行全局编号，同一时刻，只有一个写操作被批准，同时并发的写操作要去争取选票，\n　　只有获得过半数选票的写操作才会被 批准（所以永远只会有一个写操作得到批准），其他的写操作竞争失败只好再发起一\n　　轮投票，就这样，在日复一日年复一年的投票中，所有写操作都被严格编号排 序。编号严格递增，当一个节点接受了一个\n　　编号为100的写操作，之后又接受到编号为99的写操作（因为网络延迟等很多不可预见原因），它马上能意识到自己 数据\n　　不一致了，自动停止对外服务并重启同步过程。任何一个节点挂掉都不会影响整个集群的数据一致性（总2n+1台，除非挂掉大于n台）。\n总结\n　• Zookeeper 作为 Hadoop 项目中的一个子项目，是 Hadoop 集群管理的一个必不可少的模块，它主要用来控制集群中的数据，")]),e._v(" "),o("p",[e._v("如它管理 Hadoop 集群中的 NameNode，还有 Hbase 中 Master Election、Server 之间状态同步等。\\")]),e._v(" "),o("p",[e._v("关于Paxos算法可以查看文章 "),o("a",{attrs:{href:"https://www.douban.com/note/208430424/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Zookeeper全解析——Paxos作为灵魂"),o("OutboundLink")],1)]),e._v(" "),o("p",[e._v("推荐书籍：《从Paxos到Zookeeper分布式一致性原理与实践》")]),e._v(" "),o("h4",{attrs:{id:"_9、observer"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_9、observer"}},[e._v("#")]),e._v(" "),o("strong",[e._v("9")]),e._v("、Observer")]),e._v(" "),o("p",[e._v("• Zookeeper需保证高可用和强一致性；\n　• 为了支持更多的客户端，需要增加更多Server；\n　• Server增多，投票阶段延迟增大，影响性能；\n　• 权衡伸缩性和高吞吐率，引入Observer\n　• Observer不参与投票；\n　• Observers接受客户端的连接，并将写请求转发给leader节点；\n　• 加入更多Observer节点，提高伸缩性，同时不影响吞吐率")]),e._v(" "),o("h4",{attrs:{id:"_10、-为什么zookeeper集群的数目-一般为奇数个"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_10、-为什么zookeeper集群的数目-一般为奇数个"}},[e._v("#")]),e._v(" "),o("strong",[e._v("10")]),e._v("、 为什么zookeeper集群的数目，一般为奇数个？")]),e._v(" "),o("p",[e._v("•Leader选举算法采用了Paxos协议；\n　•Paxos核心思想：当多数Server写成功，则任务数据写成功如果有3个Server，则两个写成功即可；如果有4或5个Server，则三个写成功即可。\n　•Server数目一般为奇数（3、5、7）如果有3个Server，则最多允许1个Server挂掉；如果有4个Server，则同样最多允许1个Server挂掉由此，")]),e._v(" "),o("p",[e._v("我们看出3台服务器和4台服务器的的容灾能力是一样的，所以为了节省服务器资源，一般我们采用奇数个数，作为服务器部署个数。")]),e._v(" "),o("h4",{attrs:{id:"_11、zookeeper-的数据模型"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_11、zookeeper-的数据模型"}},[e._v("#")]),e._v(" "),o("strong",[e._v("11")]),e._v("、Zookeeper 的数据模型")]),e._v(" "),o("p",[e._v("» 层次化的目录结构，命名符合常规文件系统规范\n　» 每个节点在zookeeper中叫做znode,并且其有一个唯一的路径标识\n　» 节点Znode可以包含数据和子节点，但是EPHEMERAL类型的节点不能有子节点\n　» Znode中的数据可以有多个版本，比如某一个路径下存有多个数据版本，那么查询这个路径下的数据就需要带上版本\n　» 客户端应用可以在节点上设置监视器\n　» 节点不支持部分读写，而是一次性完整读写")]),e._v(" "),o("h4",{attrs:{id:"_12、zookeeper-的节点"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_12、zookeeper-的节点"}},[e._v("#")]),e._v(" "),o("strong",[e._v("12")]),e._v("、Zookeeper 的节点")]),e._v(" "),o("p",[e._v("» Znode有两种类型，短暂的（ephemeral）和持久的（persistent）\n　» Znode的类型在创建时确定并且之后不能再修改\n　» 短暂znode的客户端会话结束时，zookeeper会将该短暂znode删除，短暂znode不可以有子节点\n　» 持久znode不依赖于客户端会话，只有当客户端明确要删除该持久znode时才会被删除\n　» Znode有四种形式的目录节点\n　» PERSISTENT（持久的）\n　» EPHEMERAL(暂时的)\n　» PERSISTENT_SEQUENTIAL（持久化顺序编号目录节点）\n　» EPHEMERAL_SEQUENTIAL（暂时化顺序编号目录节点）")]),e._v(" "),o("h4",{attrs:{id:"_13、为什么需要-zookeeper"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_13、为什么需要-zookeeper"}},[e._v("#")]),e._v(" 13、为什么需要 Zookeeper")]),e._v(" "),o("p",[e._v("很多中间件，比如Kafka、Hadoop、HBase，都用到了 Zookeeper，于是很多人就会去了解这个 Zookeeper 到底是什么，为什么它在分布式系统里有着如此无可替代的地位。")]),e._v(" "),o("p",[e._v("在踩了很多坑之后，我决定来回答下这个问题。")]),e._v(" "),o("p",[o("strong",[e._v("其实学任何一项技术，首先都要弄明白，为什么需要这项技术。")])]),e._v(" "),o("p",[o("strong",[e._v("为什么需要 Zookeeper")])]),e._v(" "),o("p",[o("strong",[e._v("正经点来回答，就是我们需要一个用起来像单机但是又比单机更可靠的东西。")])]),e._v(" "),o("p",[e._v("下面开始不正经的回答。")]),e._v(" "),o("p",[e._v("一个团队里面，需要一个leader，leader是干嘛用的？管理什么的咱不说，就说如果外面的人，想问关于这个团队的一切事情，首先就会去找这个leader，因为他知道的最多，而且他的回答最靠谱。")]),e._v(" "),o("p",[e._v("比如产品经理小饼过来要人，作为leader，老吕发现小耀最近没有项目安排，于是把小耀安排给了小饼的项目；")]),e._v(" "),o("p",[e._v("过了一会，另一个产品小西也过来要人，老吕发现刚刚把小耀安排走了，已经没人，于是就跟小西说，人都被你们产品要走了，你们产品自己去协调去。")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/opersdev/image/i/2022/06/13/62a6e6e71057f.jpg",alt:"https://pic2.zhimg.com/v2-a8680b2d25fdb1514a67b2a6c6ce29ad_r.jpg"}})]),e._v(" "),o("p",[e._v("如果老吕这时候忘了小耀已经被安排走了，把小耀也分配给小西，那到时两个产品就要打架了。")]),e._v(" "),o("p",[e._v("这就是leader在团队里的"),o("strong",[e._v("协调作用")]),e._v("。")]),e._v(" "),o("p",[e._v("同样的，在分布式系统中，也需要这样的协调者，来回答系统下各个节点的提问。")]),e._v(" "),o("p",[e._v("比如我们搭建了一个数据库集群，里面有一个Master，多个Slave，Master负责写，Slave只读，我们需要一个系统，来告诉客户端，哪个是Master。")]),e._v(" "),o("p",[e._v("有人说，很简单，我们把这个信息写到一个Java服务器的内存就好了，用一个map，key:master，value:master机器对应的ip")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/opersdev/image/i/2022/06/13/62a6e6e743fde.jpg",alt:"https://pic3.zhimg.com/v2-0095c9a6e471cd92e80cd77a9909eba6_r.jpg"}})]),e._v(" "),o("p",[e._v("但是别忘了，这是个单机，一旦这个机器挂了，就完蛋了，客户端将无法知道到底哪个是Master。")]),e._v(" "),o("p",[e._v("于是开始进行拓展，拓展成三台服务器的集群。")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/opersdev/image/i/2022/06/13/62a6e6e77b564.jpg",alt:"https://pic1.zhimg.com/v2-ddfe9dbf5ae13ca335e804ae5124181c_r.jpg"}})]),e._v(" "),o("p",[e._v("这下问题来了，如果我在其中一台机器修改了Master的ip，数据还没同步到其他两台，这时候客户端过来查询，如果查询走的是另外两台还没有同步到的机器，就会拿到旧的数据，往已经不是master的机器写数据。")]),e._v(" "),o("p",[e._v("所以我们需要这个存储master信息的服务器集群，做到当信息还没同步完成时，不对外提供服务，阻塞住查询请求，等待信息同步完成，再给查询请求返回信息。")]),e._v(" "),o("p",[e._v("这样一来，请求就会变慢，变慢的时间取决于什么时候这个集群认为数据同步完成了。")]),e._v(" "),o("p",[e._v("假设这个数据同步时间无限短，比如是1微妙，可以忽略不计，那么其实这个分布式系统，就和我们之前单机的系统一样，既可以保证数据的一致，又让外界感知不到请求阻塞，同时，又不会有SPOF（Single Point of Failure）的风险，即不会因为一台机器的宕机，导致整个系统不可用。")]),e._v(" "),o("p",[o("strong",[e._v("这样的系统，就叫分布式协调系统。谁能把这个数据同步的时间压缩的更短，谁的请求响应就更快，谁就更出色，Zookeeper就是其中的佼佼者。")])]),e._v(" "),o("p",[o("strong",[e._v("它用起来像单机一样，能够提供数据强一致性，但是其实背后是多台机器构成的集群，不会有SPOF。")])]),e._v(" "),o("p",[e._v("其实就是CAP理论中，满足CP，不满足A的那类分布式系统。")]),e._v(" "),o("p",[e._v("如果把各个节点比作各种小动物，那协调者，就是动物园管理员，这也就是Zookeeper名称的由来了，从名字就可以看出来它的雄心勃勃。")]),e._v(" "),o("p",[e._v("讲完了上面这些，现在再来看官网这句话，就很能理解了：")]),e._v(" "),o("p",[e._v("ZooKeeper: A Distributed Coordination Service for Distributed Applications")]),e._v(" "),o("p",[e._v("当然还有这句：")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/opersdev/image/i/2022/06/13/62a6e6e7b3e38.jpg",alt:"https://pic3.zhimg.com/v2-cbf1a84a21a2a752246c7869159104ca_r.jpg"}})]),e._v(" "),o("p",[e._v("而以往的很多ZK教程，上来就是“Zookeeper是开源的分布式应用协调系统”blabla，很多像我这样的小年轻看到就会很费解，到底什么是分布式协调，为什么分布式就需要协调 …")]),e._v(" "),o("p",[e._v("上面只是回答了我自己提出的问题，为什么需要Zookeeper，或者说，为什么需要分布式协调系统，如果想进一步学习 ZK，你还需要了解下 Zookeeper 的内部实现原理。")]),e._v(" "),o("p",[e._v("比如 ZK 的宏观结构：")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/opersdev/image/i/2022/06/13/62a6e6e7ef963.jpg",alt:"https://pic4.zhimg.com/v2-47dfeb81a0173717f73c429d9a790b2f_r.jpg"}})]),e._v(" "),o("p",[e._v("到 ZK 的微观：")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/opersdev/image/i/2022/06/13/62a6e6e8321bd.jpg",alt:"https://pic2.zhimg.com/v2-f5580e0b031e713b72ac474d046dfe1d_r.jpg"}})]),e._v(" "),o("p",[e._v("再到 ZK 是如何实现高性能的强一致的，即ZAB协议的原理，很多教程上来就开始介绍ZAB协议，很容易让人一头雾水，不知道为什么需要这样一个分布式一致性协议，有了上述介绍的背景，就好懂许多。")]),e._v(" "),o("p",[e._v("当然你还可以比较一下最近几年很火的 etcd 跟 ZK 的差别。")]),e._v(" "),o("p",[e._v("最后推荐两份 ZK 的学习资源：")]),e._v(" "),o("p",[e._v("·     "),o("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//zookeeper.apache.org/doc/r3.5.5/zookeeperOver.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZK官网"),o("OutboundLink")],1)]),e._v(" "),o("p",[e._v("·     《从 Paxos 到 Zookeeper》")]),e._v(" "),o("p",[e._v("== updated on 2019/06/14 ==")]),e._v(" "),o("p",[e._v("看完这篇文章之后，读者可能还有疑问，为什么就一定要用 Zookeeper，我用其他的也可以呀。")]),e._v(" "),o("p",[e._v("这点是我的锅，在写这篇文章时，我还是把 Zookeeper 等价成了分布式协调服务，把为什么需要 Zookeeper 这个问题，等价成了 「为什么需要分布式协调服务」，其实这样是有问题的，因为想做分布式协调服务，不一定需要ZK这种CP的中间件，用AP也可以。")]),e._v(" "),o("p",[o("strong",[e._v("而到底是用AP还是CP，是由业务决定的。")])]),e._v(" "),o("p",[e._v("比如你是一个文件上传的服务器，用户可能上传几个g的文件，那么如果用一个AP的系统，拿到的可能是不可用的节点，这样返回给客户端重试，客户端肯定得疯掉，这时候就需要用CP。")]),e._v(" "),o("p",[e._v("而像 rpc 调用，调用失败了重试就好，成本代价都不大，这时候，用AP可能会更合适。")])])}),[],!1,null,null,null);r.default=v.exports}}]);