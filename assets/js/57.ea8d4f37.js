(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{549:function(t,n,a){"use strict";a.r(n);var _=a(22),e=Object(_.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h4",{attrs:{id:"一、应急解决办法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、应急解决办法"}},[t._v("#")]),t._v(" 一、应急解决办法")]),t._v(" "),a("p",[t._v("在MySQL数据库连接数很多,而且大多属于活跃的状态时MySQL机器基本上负载很高,属于基本上快要死去的状态了. 这时怎么办呢?")]),t._v(" "),a("p",[t._v("有可能两个办法.")]),t._v(" "),a("p",[t._v("第一: 先限制Innodb的并发处理.如果innodb_thread_concurrency = 0 可以先改成 16或是64 看机器压力,如果 非常大,先改成16让机器的压力下来,然后慢慢增达,适应自已的业务. 处理方法:")]),t._v(" "),a("p",[t._v("set global innodb_thread_concurrency=16;")]),t._v(" "),a("p",[t._v("第二: 对于连接数已经超过600或是更多的情况,可以考虑适当的限制一下连接数,让前端报一下错,也别让DB挂了. DB在了,总是可以用来加载一下数据,当数据加载到了nosql里了,慢慢的DB压力也会降下来的. 限制单用户连接数在500以下. 如:")]),t._v(" "),a("p",[t._v("set global max_user_connections=500;")]),t._v(" "),a("p",[t._v("(MySQL随着连接数的增加性能会是下降的,这也是thread_pool出现的原因) 另外对于有的监控程序会读取information_schema下面的表的程序可以考虑关闭下面的参数 innodb_stats_on_metadata=0")]),t._v(" "),a("p",[t._v("set global innodb_stats_on_metadata=0;")]),t._v(" "),a("p",[t._v("这个参数主要防止对读取information_schema时造成大量读取磁盘进行信息统计(如果慢查询中出现关于information_schema中表时,也可以考虑禁用该参数)")]),t._v(" "),a("h4",{attrs:{id:"二、问题分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、问题分析"}},[t._v("#")]),t._v(" 二、问题分析")]),t._v(" "),a("p",[t._v("思路：\n1、确定高负载的类型 htop，dstat命令看负载高是CPU还是IO\n2、监控具体的sql语句，是insert update 还是 delete导致高负载\n3、检查mysql日志\n4、检查硬件问题")]),t._v(" "),a("p",[t._v("dstat")]),t._v(" "),a("p",[t._v("可以看到具体是哪个用户哪个进程占用了相关系统资源，当前CPU、内存谁在使用")])])}),[],!1,null,null,null);n.default=e.exports}}]);